# 内容总结

## 汇编语言

+ 通用寄存器（32位和64位时代）
  + 32位中有eax, ecx, edx, ebx, esi, edi, esp, ebp。其中esp是堆栈指针寄存器，和函数调用与返回有关。eax是用于保存返回值的寄存器
+ 指针索引尽量用size_t
+ 浮点作为参数和返回，xmm系列寄存器
  + xmm寄存器有128位宽
  + 可以容纳4个float，或则2个double
+ addss是什么意思？
  + 可以拆分成三个部分add, s, s
  + 第一个s(scalar)表示标量，只对xmm的最低位进行运算。也可以是p(packed)表示矢量，一次对xmm中所有位进行计算。
  + 第二个s表示单精度浮点，即float类型。也可以是d表示双精度浮点，及double类型。
  + **如果你看到编译器生成的汇编里，有大量ss结尾的指令则说明矢量化失败。如果看到大多数都是ps结尾，则说明矢量化成功**。
+ 为什么需要SIMD？单个指令处理四个数据
  + 这种单指令处理多数据的技术叫做SIMD
  + 可以大大增加计算密集型程序的吞吐量
  + 因为SIMD把4个float打包到一个xmm寄存器中同时运算，很像数学中矢量的逐元素加法
  + 在一定条件下，编译器能够把一个处理标量float的代码，转换成一个利用SIMD指令的处理矢量float的代码

## 化简

+ 编译器优化

  + 代数优化

  + 常量折叠

  + 尽量避免代码复杂化，避免使用会造成new/delete的容器。即内存分配在堆上的容器
  + 存储在堆上妨碍优化，存储在栈上利于优化
  + vector, map, set, string, funtion, any, unique_ptr, shared_ptr, weak_ptr
  + array, bitset, string_view, pair, tuple, optional, variant
  + constexpr，强迫编译器在编译器求值
+ 内联

  + call指令变成jump
  + @PLT是Procedure Linkage Table缩写，即函数链接表。连接器会查找其他.o文件中是否定义了这个符号
  + 只有定义在同一个文件的函数可以被内联！否则编译器看不起函数体的内容怎么内联呢？
  + 为了效率我们尽量把常用函数定义在都文件，然后声明为static，这样编译器能看到他们函数体，从而有机会内联。
+ 指针

  + 指针别名现象，即b和c指向同一个变量，然后编译器不敢优化
  + 告诉编译器别害怕指针别名：__restrict关键字
    + 这是一个提示性关键之，是程序员向编译器的保证，告诉它这些指针不会发生重叠！
  + 只需加在非const的即可，因为const的是静止写入访问的。
  + **volatile**关键字禁止优化
    + 这种对象，编译器会放弃优化对他的**读写操作**
  + 注意：语法上区别：`volatile` 在 `*` 前面而` __restrict` 在 `*` 后面。功能上区别：`volatile` 是禁用优化，`__restrict` 是帮助优化

## 矢量化

+ 更宽的合并写入，矢量化指令(SIMD)
+ xmm0有SSE引入，是一个128位寄存器，他也可以一起存储4个float
+ 再宽一点？ymm0是256位的，不过这个寄存器需要电脑支持AVX指令集。但编译器不敢保证，所以优化成xmm0
+ 让编译器建成当前支持的指令集，`-march=native`判断当前硬件支持的指令。
+ 数组清零，自动调用标准库的memset。对于memcpy同理。

### 循环

+ OpenMP强制矢量化，`#pragma omp simd`。要启用`-fopenmp`
+ `#pragma GCC ivdep`提示编译器忽略指针别名。当然也可以用`__restrict`关键字
+ 循环中的if语句挪到外面来
+ 循环中的不变量挪到外面来，避免重复计算。
+ 调用不在一个文件的函数， SIMD优化失败。因此，循环中调用的函数最好放在同一个文件中。
+ 循环中的下标，随机访问优化失败，顺序访问优化成功。
  + 不管是编译器还是CPU，都喜欢顺序的连续访问。
+ 为什么要循环展开？
  + 每次执行循环体，都要进行一次判断 。导致一部分时间花在判断是否结束循环，而不是循环体里。
+ `#pragma GCC unroll 4`。对小循环体进行unroll可能是划算的，但最好不要unroll大的循环体，否则会造成指令缓存的压力反而变慢。

### 结构体

+ 对齐到2的整数幂，2, 4, 8, 16, 32, 64， 128...
+ 结构体大小若不是2的整数幂，往往会导致SIMD优化失败
+ C++11, `alignas`语法
+ 内存布局
  + AOS和SOA。AOS单个对象的属性紧挨着存，SOA属性分离存储在多个数组
  + AOS必须对齐到2的幂才高效，符合OOP的习惯。SOA有利于性能，又称面向数据编程。
  + 中间方案，AOSOA，4个对象一组打包称SOA，再用一个 n/4大小的数据存储为AOS

## 数学运算

+ 除法变乘法
+ `-ffast-math`,让GCC更大胆常数浮点数运算优化。
+ 嵌套循环，直接累加，有指针别名问题
  + 先读到局部变量，累加完毕后，再写入
  + 先累加到初始为0的局部变量，再累加