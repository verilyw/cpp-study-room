# 内容总结

+ C++历史

  + 古代(C语言)， 一个数组的内存分配，malloc
  + 近代(C++98)， vector但不能直接初始化元素，需要根据索引初始化
  + 近现代(C++11)， 引入{}初始化表达式。引入range-based for-loop
    + for-each算法模板，lambda表达式
    + 14允许lambda使用auto自动推导
  + 当代(C++17)，CTAD编译器参数推断。引入常用的数值算法，如reduce
    + 20引入range, concept, module，coroutine和generator
    + 20允许函数参数自动推导(auto)

+ C++有哪些面向对象思想

  + 封装，将多个逻辑上相关的变量包装成一个类
    + 比如要表达一个数组，需要起始地址指针v，数组大小nv
    + 封装不变性，当需要修改一个成员时，其他成员需要被修改，否则出错这种情况出现时，就意味着要把承压u你变量读写封装成成员函数

+ RAII

  + 资源获取即初始化，反之资源释放视为销毁。用于初始化的构造函数和用于销毁的解构函数
  + 避免犯错误，如果没有解构函数，需要手动释放资源，会很麻烦。C++的解构函数是显示的，离开作用域自动销毁。RAII离不开解构函数
  + 异常安全(exception-safe)，标准保证当异常发生时，会调用已创建的解构函数。因此C++中没有(也不需要)finally语句。

+ 自定义构造函数

  + 无参数（使用初始化表达式）
  + 为什么需要初始化表达式？
    + 假如类成员为const和引用
    + 假如类成员没有无参数构造函数
    + 避免重复初始化，更高校
  + 单个参数和多个参数
    + 单参数陷阱，隐式转换。
    + 使用`explicit`禁止隐式转换。**对多个参数，explicit的作用体现在禁止从一个{}表达式初始化**

+ 编译器默认生成的构造函数（无参数）

  + 小心POD陷阱！
  + 当一个类没有定义任何构造函数，其所有成员函数都有无参构造时，编译器会自动生成一个无参构造。
  + 注意这些类型不会被初始化为0
    + int, float, double等基础类型
    + `void*`, `Object*`等指针类型
    + 完全由这些类型组成的类型
  + 这些类型被称为`POD(plain-old-data)`
  + POD的存在是处于兼容性和性能的考虑
  + 初始化列表，将{}内的内容按顺序赋值给对象的每一个成员。方便程序员不必手写冗长的构造函数一个个赋值给成员

+ 拷贝构造函数和拷贝赋值

  + 除了无参数和初始化列表构造函数外，编译器还会自动生成拷贝构造和拷贝赋值
  
  
  
+ 三五法则
  
  + 默认拷贝构造函数对指针成员是浅拷贝，而不深拷贝整个内存。当释放时造成二次释放，即同一个地址释放两次，出错。因此，要么删除，要么实现定义深拷贝。
  + 拷贝赋值函数约等于解构函数 + 拷贝构造函数
    + 拷贝构造：直接在未初始化内存上构造2
    + 拷贝赋值：先销毁现有的1,再重新构造2
  + 拷贝赋值函数提高性能
    + 内存的销毁重新分配可以通过realloc，从而就地利用当前现有的m_data，避免重新分配。
    + 如果一个类定义或删除了拷贝构造函数，那么您必须同时定义或删除拷贝赋值函数，否则出错
  
+ C++11: 为什么区分拷贝和移动？

  + 有时候，我们需要吧一个对象v2移动到v1上，而不需要涉及到实际数据的拷贝。
  + 时间复杂度：移动是O(1)，拷贝是O(n)

+ 移动进阶

  + 除了`std::move`可以把v2移动到v1外。还可以通过`std::swap`交换v1和v2
  + swap在高性能计算可以用来实现双缓存

  

+ 移动构造函数和移动赋值
  + 移动赋值约等于解构 + 移动构造
  + （小技巧）如果有移动赋值函数，可以删除拷贝赋值

+ 智能指针

  + 在没有智能指针的c++中，我们智能手动new 和 delete 指针。非常容易出错。
  + RAII解决内存管理的问题
    + unique_ptr和原始指针一起用
    + shared_ptr和weak_ptr一起用