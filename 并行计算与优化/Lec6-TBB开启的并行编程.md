# 内容总结

## 并发到并行

+ 摩尔定律提供的免费午餐结束啦！依靠单核性能的增长带来程序性能的时代落幕
+ 并发与并行的区别（运行多线程的方式和动机）
  + 并发可以是单核处理器，将多个任务切分称许多小块，然后通过时间片调度算法，轮换着执行不同线程，看起来就好像同时运行一样，其实每一个时刻只有一个线程在运行。目的：异步地处理多个不同任务，避免同步造成的阻塞。
  + 多核处理器，每个处理器都执行一个线程，真正的同时运行。目的：将一个任务派到多个和上，更快完成任务。

## TBB

因特尔开源的并行编程库



+ 任务组

  + tbb::task_group
  + 一个任务不一定对应一个线程，如果任务数量超过CPU最大的线程数，会由TBB在用户层面负责调度任务运行在多个预先分配好的线程，而不是由操作系统负责调度线程运行在多个物理核心。

  + 封装好的
    + parallel_invoke

### 并行循环

+ 时间复杂度与工作量复杂度
  + 时间复杂度：程序所用的总时间（重点）
  + 工作复杂度：程序所用的计算量（次要）
  + 这两个指标都是越低越好。时间复杂度决定了快慢，工作复杂度决定了耗电量。
  + 通常来说，工作复杂度 = 时间复杂度 * 核心数量
  + **并行的主要目的是降低时间复杂度，工作复杂度通常是不变的。**甚至有牺牲工作复杂度换取时间复杂度的情形。
+ 映射（map）
  + `void paralle_for(const Range &range, const Body &body)`
+ 基于迭代器区间：parallel_for_each
+ 二维区间上的for循环：blocked_range2d

### 缩并与扫描

+ reduce
  + `parallel_reduce`
  + 保证每次结果一致: parallel_deterministic_reduce
+ 扫描
  + 和缩并差不多，只不过他会把求和的**中间结果存到数组中去**
  + `parallel_scan`

### 性能测试

+ map与reduce组合
+ 公式：加速比=串行用时÷并行用时
+ 理想加速比应该是核心的数量。Source-Free Image Supe
+ 更专业的测试框架，google benchmark



## 任务域与嵌套

+ 任务域
  + task_arena
  + 指定使用线程
+ 嵌套for循环
  + 死锁问题
  + TBB采用了**工作窃取法**来分配任务：当一个线程t1做完自己队列里的全部工作时，会从另外一个工作线程t2的队列里取出任务，以免t1闲置浪费时间
  + 因此，内部for循环有可能“窃取"到另外一个外部for循环的任务，从而导致mutex被重复上锁
  + 用递归锁`std::recursive_mutex`可以解决
  + 创建另外一个任务域，这样不同域之间就不会窃取工作
  + 同一个任务域，但用isolate隔离，禁止其内部的工作被窃取(推荐)



### 任务分配

+ 并行：如何平均分配任务到每个线程？
  + 线程数量超过CPU核心数量，让系统调度保证核心始终饱和
  + 线程数量不变，但用一个队列分发和认领任务
  + 每个线程一个任务队列，做完本职工作后可以认领其他线程的任务
  + 随机分配法（通过哈希函数或者线性函数）
  + static_partitioner
  + simple_partitioner
  + auto_partitioner

### 并发容器

+ concurrent_vector
+ ....

### 并行筛选

+ filter
+ 
