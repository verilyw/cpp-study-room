# 内容总结

+ 为什么需要模板函数？
  + 避免重复写代码
  + 与面向对象思想不同

## 模板函数

+ 模板函数：自动推导参数类型
  + 当模板类型参数T作为函数参数时，则可省略该模板参数。
+ 模板函数：特化的重载
  + 有时候，一个统一的实现（比如 t * 2）满足不了某些特殊情况。比如std::string不能用乘法来重复，需要添加一个 t + t来替代。
  + SFINAE
+ 模板函数：默认参数类型
  + 如果模板类型参数T 没有出现在函数的参数中，那么编译器就无法推断，就不得不手动指定了。
  + 也可以通过设置默认的类型，比如 `template< typename T = int> `

## 模板参数

+ 整数也可以作为参数

  + 除了类型，任意整数也可以作为模板参数
  + 比如`template<int N >`
  + 模板参数只支持整数类型(包括 enum)
  + 浮点类型，指针类型不能声明为模板参数，当然，自定义类型也不可以

+ 多个模板参数

  + typename(class) T 和 int N可以一起使用

  + 只需要指定其中一部分参数即可，会自动更具参数类型，默认置，推断尖括号中没有指定哪些参数。

  + ```c++
    template <typename T, int N = 1>
    void show_times(T msg) {
        for (size_t i = 0; i < N; i++) {
            std::cout << msg << '\n';
        }
    }
    ```
  
+ 参数部分特化

  + `func(T t)`完全让参数类型取决于调用者
  + `func(vector<T> t)`这样则可以限定仅为vector类型的参数
  + **这种部分特化不支持隐式转换**

+ 为什么要支持整数作为模板参数？
  + 因为是编译期常量
  + 模板参数和函数参数有很大区别！
    + 一个是编译期，一个是运行期常量
  + 通常来说，模板内部实现必须暴露出来，除非使用特殊手段，否则，定义和实现都必须放在头文件里。
  + 因为如此，过度使用模板，会导致生成的二进制文件大小剧增，编译变得很慢。

## 模板应用和难题

编译期优化案例：

```c++
int sumto(int n, bool debug) {
    int res = 0;
    for (size_t i = 1; i <= n; i++) {
        res += i;
        if (debug) {
            std::cout << i << "-th" << res << std::endl;
        }
    }
    return res;
}
```

+ 用一个debug参数控制是否输出调试信息
+ 但这样debug是运行时推断，这样即使debug为false也会浪费cpu时间

+ 因此，可以把debug改成模板参数，这样就是编译器常量。

编译器分支

+ c++17的 if constexpr语法。
+ 编译器常量的限制
  + 编译器常量限制在于他不能通过运行时变量组成的表达式来指定。

编译期常函数

+ constexpr的表达式，一般是无法调用其他函数的。
+ 如果保证func在编译器求值，在签名前加上constexpr

+ 注意constexpr函数不能调用non-constexpr函数。并且constexpr函数必须是内联的。

分离定义，即移动到另外一个文件中定义

+ 一般来说，建议模板不要分离声明和定义，直接写在头文件即可。如果分离还要罗列出所有模板参数的排列组合。
+ 编译器对模板的编译是**惰性的**，即只有当前cpp文件用到了这个模板，该模板里的函数才会被定义。

## 自动类型推导

+ auto，不用在手写很长的类型的变量的声明和定义了 ，其类型会通过等号右边来自动推导
+ 但也有限制，没有 = 单独声明一个auto变量是不行的。类成员也不能定义为 auto

+ 函数返回值
  + 除了可以定义变量，还可以用作函数的返回类型
  + 也要注意，（1）当有多条return语句，所有语句返回类型必须一致。（2）没有return时，会推导成void（3）**如果声明和实现分离了，则不能声明为auto**。

## 函数式编程

+ 函数也是对象
+ 函数作为模板类型
  + 甚至可以直接将func的类型作为一个模板参数
+ lambda表达式
  + 作为参数
  + 作为返回值，出问题了！
    + 用[&]，**请保证lambda对象的生命周期不超过他捕获的所有引用的寿命。**

+ 双倍快乐！lambda + 模板
  + 可以将表达式参数声明为auto，会自动根据调用者参数推导类型。和模板函数一样，同样会有惰性，多次编译的特性。

## 常用容器

1. `tuple`
2. `optional`
3. `variant`
   1. + `std::visit`、`std::variant`的这种模式称为静态多态，和虚函数，抽象类的动态多态相比，优势是性能开销小，存储大小固定。缺点是类型固定，不能运行时扩充。