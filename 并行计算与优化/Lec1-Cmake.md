# 内容总结

+ 什么是编译器
  + 是一个根据源代码生成机器码的程序
+ 多文件编译与链接
  + 单文件虽然方便，但也有很多缺点
    + 代码堆在一起，不利于模块化和理解
    + 工程变大时，编译时间变得很长，牵一发而动全身
  + 因此，提出多文件编译的概念，文件之间通过符号声明相互引用
+ 为什么需要构建系统
  + 文件多了，比如使用`g++`这样的命令来编译链接会很麻烦
  + 于是发明了make程序，只需要写出文件之间的依赖关系和生成各文件的规则
  + make的好处
    + 可以并行
    + 可以用通配符批量生成构建规则
+ 构建系统的构建系统
  + 为了解决make的问题，cmake诞生了
  + cmake跨平台，具有相对高级的语法，内置的函数。自动检测源文件和头文件的依赖关系

+ 为什么需要库
  + 有时候我们会有多个执行文件，他们之间用到的某些功能是相同的，我们想把这些**共用的功能**做成一个库，方便大家一起共享。
  + 库可以被可执行文件调用，也可以被其他库调用
  + 库可以分为静态库和动态库
    + 静态库是直接把代码插入到生成的可执行文件中，文件体积会变大，但只需要一个可执行文件即可
    + 动态库则只在可执行文件中生成“插桩”函数，当可执行文件被加载时会读取指定目录的`.dll`文件，加载到内存空闲文职，并替换相应的插桩指向的地址为加载后的地址，这个过程称为重定向。
  + Cmake中默认是生成静态库，`add_library`
+ 为什么C++需要声明
  + 因为需要知道函数的参数和返回值类型：这样才能支持重载，隐式类型转换等特性。
  + 让编译器知道这是一个函数，不是一个变量或者类的名字。比如我写下hello()的时候，编译器知道这是一个函数，不是一个hello类的对象创建。
  + c++是一种强烈依赖上下文信息的编程语言。
+ 为什么需要头文件
  + 如果一个函数在很多文件都被使用，我们不能在每个`.cpp`中都去声明它吧，这样显得很麻烦。
  + 把声明都放在一个文件中（也就是头文件）只写一遍，然后每个文件把这个头文件插入进来，就可以使用，这样子多方便。
+ Cmake中的子模块
  + 复杂的工程中，我们需要划分子模块，通常是一个库一个目录。
+ 第三方库引入方式
  + 作为纯头文件引入，这些库是header-only的
  + 作为子模块引入，通过add_subdirectory
  + 引用系统中预安装的第三方库，通过find_package寻找
    + 现代cmake认为一个包(package)可以提供多个库，又称为组件(components)，比如TBB这个包，就包含了tbb, tbbmalloc, tbbmalloc_proxy这三个组件

