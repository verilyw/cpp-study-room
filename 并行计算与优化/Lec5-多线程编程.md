# C++11 开始的多线程编程



![image-20230607195427206](../assets/image-20230607195427206.png)

## 时间

```c
long t0 = time(NULL);    // 获取从1970年1月1日到当前时经过的秒数
sleep(3);                // 让程序休眠3秒
long t1 = t0 + 3;        // 当前时间的三秒后
usleep(3000000);         // 让程序休眠3000000微秒，也就是3秒
```



C语言原始的API，没有**类型区分**，导致很容易弄混单位，混淆**时间点和时间段**。比如 t0 * 3，乘法对时间点而言根本是个无意义的计算，然而 C 语言把他们看做一样的 long 类型，从而容易让程序员犯错。

C++11引入时间标准库：std::chrono

+ 利用c++强类型特点，明确区分了时间点和时间段，明确区分不同的时间单位。
+ 时间点例子：2023年6曰7日19点59分30秒
+ 时间段例子：2分24秒
+ 时间点类型：`chrono::steady_clock::time_point`等
+ 时间段类型：`chrono::milliseconds`，`chrono::seconds`，`chrono::minutes` 等
+ 方面的运算符重载：时间点 + 时间段 = 时间点， 时间点 - 时间点 = 时间段

```c++
auto t0 = chrono::steady_clock::now();		// 获取当前时间点
auto t1 = t0 + chrono::seconds(30);		// 当前时间点的30秒后
auto dt = t1 - t0;		// 获取两个时间点的差（时间段）
int64_t sec = chrono::duration_cast<chrono::seconds>(dt).count();  // 时间差的秒数
```

## 线程

+ 进程是一个应用程序被操作系统拉起来加载到内存之后从开始执行到执行结束的这样一个过程。简单来说，进程是程序（应用程序，可执行文件）的一次执行。比如双击打开一个桌面应用软件就是开启了一个进程。
+ 线程是进程中的一个实体，是被系统独立分配和调度的基本单位。也有说，线程是CPU可执行调度的最小单位。也就是说，进程本身并不能获取CPU时间，只有它的线程才可以。
+ 从属关系：进程 > 线程。一个进程可以拥有多个线程。
+ 每个线程共享同样的内存空间，开销比较小。
+ 每个进程拥有独立的内存空间，因此开销更大。
+ 对于高性能并行计算，更好的是多线程。

为什么需要多线程：无阻塞多任务

我们的程序常常需要同时处理多个任务。例如：后台在执行一个很耗时的任务，比如下载一个文件，同时还要和用户交互。这在 GUI 应用程序中很常见，比如浏览器在后台下载文件的同时，用户仍然可以用鼠标操作其 UI 界面。没有多线程的话，就必须等文件下载完了才能继续和用户交互。下载完成前，整个界面都会处于“未响应”状态，用户想做别的事情就做不了。

+ C++11 开始，为多线程提供了语言级别的支持。他用 std::thread 这个类来表示线程。
+ std::thread 构造函数的参数可以是任意 lambda 表达式。

有了多线程：异步处理请求

有了多线程的话，文件下载和用户交互分别在两个线程，同时独立运行。从而下载过程中也可以响应用户请求，提升了体验。

C++20 引入了 std::jthread 类，和 std::thread 不同在于：他的解构函数里会自动调用 join() 函数，从而保证 pool 解构时会自动等待全部线程执行完毕。



## 异步

异步好帮手：std::async

+ std::async 接受一个带返回值的 lambda，自身返回一个 std::future 对象。
+ lambda 的函数体将在另一个线程里执行。
+ 接下来你可以在 main 里面做一些别的事情，download 会持续在后台悄悄运行。
+ 最后调用 future 的 get() 方法，如果此时 download 还没完成，会等待 download 完成，并获取 download 的返回值。

显示地等待：wait()。

+ 除了 get() 会等待线程执行完毕外，wait() 也可以等待他执行完，但是不会返回其值。

等待一段时间：wait_for()

+ 只要线程没有执行完，wait() 会无限等下去。而 wait_for() 则可以指定一个最长等待时间，用 chrono 里的类表示单位。他会返回一个 std::future_status 表示等待是否成功。
+ 如果超过这个时间线程还没有执行完毕，则放弃等待，返回 future_status::timeout。如果线程在指定的时间内执行完毕，则认为等待成功，返回 future_status::ready。
+ 同理还有 wait_until() 其参数是一个时间点。

另一种用法：std::launch::deferred 做参数

+ std::async 的第一个参数可以设为 std::launch::deferred，这时不会创建一个线程来执行，他只会把 lambda 函数体内的运算推迟到 future 的 get() 被调用时。
+ 这种写法，download 的执行仍在主线程中，他只是函数式编程范式意义上的异步，而不涉及到真正的多线程。可以用这个实现惰性求值（lazy evaluation）之类。

std::async 的底层实现：std::promise

+ 如果不想让 std::async 帮你自动创建线程，想要手动创建线程，可以直接用 std::promise。
+ 然后在线程返回的时候，用 set_value() 设置返回值。在主线程里，用 get_future() 获取其 std::future 对象，进一步 get() 可以等待并获取线程返回值。

std::future 小贴士

+ future 为了三五法则，删除了拷贝构造/赋值函数。如果需要浅拷贝，实现共享同一个 future 对象，可以用 std::shared_future。
+ 如果不需要返回值，std::async 里 lambda 的返回类型可以为 void， 这时 future 对象的类型为` std::future<void>`
+ 同理有 `std::promise<void>`，他的 set_value() 不接受参数，仅仅作为同步用，不传递任何实际的值。

## 互斥量

多线程打架案例：

+ 两个线程同时往一个数组里推数据.....
+ vector 不是多线程安全（MT-safe）的容器。
+ 多个线程同时访问同一个 vector 会出现数据竞争（data-race）现象。

std::mutex：上锁，防止多个线程同时进入某一代码段。

std::lock_guard：符合 RAII 思想的上锁和解锁

std::unique_lock：也符合 RAII 思想，但自由度更高。std::unique_lock：用 std::defer_lock 作为参数，指定了这个参数的话，std::unique_lock 不会在构造函数中调用 mtx.lock()，需要之后再手动调用 grd.lock() 才能上锁。好处依然是即使忘记 grd.unlock() 也能够自动调用 mtx.unlock()。

如果上锁失败，不要等待：try_lock()。只等待一段时间：try_lock_for()。

## 死锁

同时锁住多个 mutex：死锁难题

+ 双方都在等着对方释放锁，但是因为等待而无法释放锁，从而要无限制等下去。这种现象称为死锁（dead-lock）。

解决1：永远不要同时持有两个锁

+ 最为简单的方法，就是一个线程永远不要同时持有两个锁，分别上锁，这样也可以避免死锁。

解决2：保证双方上锁顺序一致

+ 保证双方上锁的顺序一致，即可避免死锁

解决3：用 std::lock 同时对多个上锁

+ 如果没办法保证上锁顺序一致，可以用标准库的 std::lock(mtx1, mtx2, ...) 函数，一次性对多个 mutex 上锁

+ std::lock 的 RAII 版本：std::scoped_lock

同一个线程重复调用 lock() 也会造成死锁

+ 除了两个线程同时持有两个锁会造成死锁外，即使只有一个线程一个锁，如果 lock() 以后又调用 lock()，也会造成死锁。

+ 告诉其他人，已经上过锁了
+ 改用 std::recursive_mutex，会自动判断是不是同一个线程 lock() 了多次同一个锁，如果是则让计数器加1，之后 unlock() 会让计数器减1，减到0时才真正解锁。但是相比普通的 std::mutex 有一定性能损失。
