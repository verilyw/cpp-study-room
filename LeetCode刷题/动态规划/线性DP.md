## 0-1背包问题和完全背包

它们都是选或不选思想的代表。

### 0-1背包问题定义：有n个物品，第i个物品的体积为w[i], 价值为v[i]，每个物品至多选一个，求体积和不超过capacity时的最大价值和。

回溯三问:
+ 当前操作？
  + 枚举第i个物品选或者不选。选，剩余容量减少w[i], 不选，剩余容量不变。
+ 子问题？
  + 在剩余容量为c时，从前i个物品中得到的最大价值和
+ 下一个子问题？
  + 分类讨论：
    + 不选：在剩余容量为c时，从前i-1个问题中得到的最大价值和
    + 选：在剩余容量为c - w[i]时，从前i-1个物品中得到的最大价值和


$$ dfs(i, c) = max(dfs(i-1, c), dfs(i-1, c-w[i]) + v[i]) $$


### 完全背包：有n种物品，第i种物品的体积为w[i], 价值为v[i]，每种物品无限次重复选，求体积和不超过capacity时的最大价值和。

回溯三问：
+ 当前操作？
  + 枚举第i种物品选一个或者不选：不选，容量不变; 选一个，容量减少w[i].
+ 子问题？
  + 在剩余容量为c是，从前i中物品得到的最大价值和
+ 下一个子问题？
  + 分类讨论：
    + 不选：在剩余容量为c时，从前i-1种物品中的到的最大价值和
    + 选一个：在剩余为c-w[i]时，从**前i种**（表示可以继续选第i种）物品中得到的最大价值和

$$ dfs(i, c) = max(dfs(i-1, c), dfs(i, c-w[i]) + v[i]) $$
## 常见变形

1. **至多**装capacity, 求方案数/最大价值和
2. **恰好**装capacity, 求方案数/最大/最小价值和
3. **至少**装capacity, 求方案数/最小价值和


## 最长公共子序列

+ 转移优化
+ 空间优化

启发思路：子序列本质上是考虑选或者不选，我们考虑最后一对字母，分别叫做x和y。那么一种有四种选择方法：
1. 选x, 选y
2. 选x, 不选y
3. 不选x, 选y
4. 不选x, 不选y


回溯三问：
+ 当前操作？
  + 考虑s[i]和t[j]选或者不选
+ 子问题？
  + s的前i个字母和t前j个字母的LCS长度
+ 下一个子问题？
  + s的前i-1个字母，t的前j-1个字母的LCS长度
  + s的前i-1个字母，t的前j个字母的lcs长度
  + s的前i个字母，t的前j-1个字母的lcs长度

$$ dfs(i, j) =  max(dfs(i-1, j), dfs(i, j-1), dfs(i-1, j-1) + s[i] == t[j] $$

不能忽略的问题：
+ 在s[i] == s[j]的时候，需要dfs(i-1, j)和dfs(i, j-1)吗
+ 在s[i] != s[j]的时候，需要dfs(i-1, j-1)吗

答案是不需要的。

因此，可以简化成以下公式

$$
dfs(i, j) = dfs(i-1, j-1) + 1  \ s[i] == t[j]\\
dfs(i, j) = max(dfs[i-1, j], dfs(i, j-1)) \ s[i] != t[j] 
$$