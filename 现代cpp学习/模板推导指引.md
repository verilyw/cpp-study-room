# 推导指引


## 简单介绍

可以定义特定的**推导指引**给**类模板参数**添加新的推导或者修正构造函数定义的推导。

无论合适推导`Pair`的模板参数，推导行为都好像参数是以**值传递**的
```c++
template <class T1, class T2>
struct Pair {
    T1 first;
    T2 second;

    Pair(const T1 &x, const T2 &y) : first{x}, second{y} { }
};

// 为构造函数定义推导指引
template <class T1, class T2>
Pair(T1, T2) -> Pair<T1, T2>;

int main()
{
    Pair p{"hi", 42};
    return 0;
}
```

在`->`的左侧我们声明了 我们想要推导什么。这里我们声明的是使用两个以值传递且类型分别为`T1`, `T2`的对象创建一个`Pair`对象。
在`->`右侧，我们定义推导的结果。这个例子中，`Pair`以类型`T1`,`T2`实例化。

你可能会说这是构造函数已经做到的事情。 然而，构造函数是以引用传参，两者是不同的。**一般来说，不仅是模板，所有以值传递的参数都会退化 ，而以引用传递的参数不会退化**。 退化意味着原生数组会转换为指针，并且顶层的修饰符例如const或者引用将会被忽略。

比如没有推导指引，对于如下声明：
```c++
Pair p1{"hi", "world"};  // 有了推导指引，等价于 Pair<const char *, const char *> p1{"hi", "world"};
```
参数`x`的类型是`const char(&)[3]`，因此`T1`被推导为`char[3]`，参数`y`的类型是`const char(&)[6]`，因此`T2`被推导为`char[6]`。有了推导指引后，模板参数就会退化。这意味着两个类型都会退化为`const char *`，然后被用作模板参数的结果。

注意构造函数仍然以引用传参。推导指引只和模板参数的推导相关， 它与推导出`T1`和`T2`之后实际调用的构造函数无关。

## 使用推导指引强制类型退化

```c++
template <class T>
struct C {
    C(const T&) {

    }
    // ....
}

C x{"hello"}; // 这里T被推导为char[6]

// 通过使用一个简单的推导指引
template <class T> C(T) -> C<T>;

C x{"hello"}; // 这里T被推导为const char *
```

## 非模板推导指引
推导指引并不一定是模板，也不一定应用于构造函数。例如，为下面的结构体添加的推导指引也是有效的：

```c++
template<typename T>
struct S {
    T val;
};

S(const char*) -> S<std::string>;   // 把S<字符串字面量>映射为S<std::string>

S s1{"hello"};      // OK，等同于S<std::string> s1{"hello"};
S s2 = {"hello"};   // OK，等同于S<std::string> s2 = {"hello"};
S s3 = S{"hello"};  // OK，两个S都被推导为S<std::string>
```

这里我们创建了一个没有相应构造函数的推导指引。推导指引被用来推导参数T， 然后结构体的模板参数就相当于已经被指明了。

## 推导指引和构造函数

推导指引会和类的构造函数产生竞争。类模板参数推导时会根据重载情况选择最佳匹配的构造函数/推导指引。 **如果一个构造函数和一个推导指引匹配优先级相同，那么将会优先使用推导指引。**